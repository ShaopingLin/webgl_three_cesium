(function(e){function n(n){for(var r,o,c=n[0],l=n[1],u=n[2],d=0,s=[];d<c.length;d++)o=c[d],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&s.push(a[o][0]),a[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(e[r]=l[r]);v&&v(n);while(s.length)s.shift()();return i.push.apply(i,u||[]),t()}function t(){for(var e,n=0;n<i.length;n++){for(var t=i[n],r=!0,c=1;c<t.length;c++){var l=t[c];0!==a[l]&&(r=!1)}r&&(i.splice(n--,1),e=o(o.s=t[0]))}return e}var r={},a={app:0},i=[];function o(n){if(r[n])return r[n].exports;var t=r[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.m=e,o.c=r,o.d=function(e,n,t){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,n){if(1&n&&(e=o(e)),8&n)return e;if(4&n&&"object"===typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)o.d(t,r,function(n){return e[n]}.bind(null,r));return t},o.n=function(e){var n=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="/webgl_three_cesium/";var c=window["webpackJsonp"]=window["webpackJsonp"]||[],l=c.push.bind(c);c.push=n,c=c.slice();for(var u=0;u<c.length;u++)n(c[u]);var v=l;i.push([0,"chunk-vendors"]),t()})({0:function(e,n,t){e.exports=t("56d7")},"10c7":function(e,n,t){},"56d7":function(e,n,t){"use strict";t.r(n);t("e260"),t("e6cf"),t("cca6"),t("a79d");var r=t("7a23");function a(e,n){var t=Object(r["t"])("router-view");return Object(r["n"])(),Object(r["c"])(t)}t("57ed");var i=t("6b0d"),o=t.n(i);const c={},l=o()(c,[["render",a]]);var u=l,v=t("6c02"),d={class:"home"};function s(e,n,t,a,i,o){return Object(r["n"])(),Object(r["d"])("div",d,[Object(r["e"])("div",{onClick:n[0]||(n[0]=function(){return a.water&&a.water.apply(a,arguments)})},"去水")])}var f={name:"Home",components:{},setup:function(){Object(v["c"])();var e=Object(v["d"])();function n(){e.push("/water")}return{water:n}}};const p=o()(f,[["render",s]]);var m=p,w=function(e){return Object(r["q"])("data-v-19c26887"),e=e(),Object(r["o"])(),e},x={class:"waterRoot"},g=w((function(){return Object(r["e"])("div",{id:"threeContainer"},null,-1)})),h=[g];function b(e,n,t,a,i,o){return Object(r["n"])(),Object(r["d"])("div",x,h)}var y=t("5a89"),D=t("5c40"),j=t("4721"),P=t("34ad"),F=t("32d9"),z=t("360d"),M=t("93e9"),O=(t("31f6"),{name:"Water",setup:function(e,n){Object(D["v"])((function(){var e,n,t,r=(new y["vb"]).load("textures/Material.001_baseColor.png"),a=(new y["vb"]).load("textures/normal.png"),i=document.getElementById("threeContainer"),o=new y["bb"](70,window.innerWidth/window.innerHeight,.01,1e3);o.position.z=10.2,o.position.y=.5;var c=new y["lb"],l=new y["lb"],u=new y["lb"],v=new y["cb"](10,10,1,1),d=new y["mb"]({uniforms:{cameraNear:{value:o.near},cameraFar:{value:o.far},groundNTx:{value:a}},vertexShader:"\n                varying vec2 vUv;\n                varying vec3 v_position;\n                varying vec3 v_normal;\n                void main() {\n                    vUv = uv;\n                    v_normal = normalMatrix * normalize(normal);\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n                }",fragmentShader:"\n                #include <packing>\n                varying vec2 vUv;\n                varying vec3 v_normal;\n                uniform float cameraNear;\n                uniform float cameraFar;\n                uniform sampler2D groundNTx;\n                void main() {\n                    vec3 nDetail = texture2D(groundNTx,vUv).rgb;\n                    vec3 n = normalize(v_normal*nDetail);\n                    vec3 nv_color = n * 0.5 + 0.5;\n                    vec4 final2;\n                    final2 = vec4(nv_color,1.);\n                    gl_FragColor = final2;\n\n                }"}),s=new y["P"](v,d);s.rotation.x=-Math.PI/2,s.updateMatrix(),l.add(s);var f=new y["cb"](10,10,1,1),p=new y["R"]({map:r}),m=new y["P"](f,p);m.rotation.x=-Math.PI/2,u.add(m);var w=new y["Eb"]({antialias:!0});w.setSize(window.innerWidth,window.innerHeight),w.setAnimationLoop(S),t=new M["a"](c,o),e=new F["a"](w),e.addPass(t);var x=k({x:0,y:0,width:window.innerWidth,height:window.innerHeight},{near:0,far:1});n=new z["a"]({glslVersion:y["s"],uniforms:{tDiffuse:{value:null},tDepth:{value:null},cameraNear:{value:o.near},cameraFar:{value:o.far},tNormal:{value:null},groundDepth:{value:null},viewPortMatrixInverse:{value:x},projectionMatrixInverse:{value:o.projectionMatrixInverse},cameraProjectionMatrix:{value:o.projectionMatrix},u_resolution:{value:new y["Ab"](window.innerWidth,window.innerHeight)},groundTexture:{value:null}},vertexShader:"\n                varying vec2 vUv;\n                varying vec3 v_position;\n                varying mat4 v_mvMatrix;\n                void main() {\n                    vUv = uv;\n                    v_mvMatrix = modelViewMatrix;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n                }",fragmentShader:"\n                #include <packing>\n                varying vec2 vUv;\n                uniform float cameraNear;\n                uniform float cameraFar;\n                uniform sampler2D tDiffuse;\n                uniform sampler2D tDepth;\n                uniform sampler2D tNormal;\n                uniform sampler2D groundDepth;\n                uniform mat4 viewPortMatrixInverse;\n                uniform mat4 projectionMatrixInverse;\n                uniform mat4 cameraProjectionMatrix;\n                uniform vec2 u_resolution;\n                uniform sampler2D groundTexture;\n                float readDepth( sampler2D depthSampler, vec2 coord ) {\n                    float fragCoordZ = texture2D( depthSampler, coord ).x;\n                    float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n                    return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n                }\n                vec3 getViewNormal( const in vec2 uv ) {\n                    return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );\n                }\n                float getViewZ( const in float depth ) {\n                    return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n                }\n                vec4 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n                    vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n                    clipPosition *= clipW; //clip\n                    return ( projectionMatrixInverse * clipPosition );//view\n                }\n                void main() {\n                    float maxDistance = 25.;\n                    float resolution  = 1.;\n                    float thickness   = .2;\n                    \n\n                    vec4 color = texture2D(tDiffuse,vUv);\n                    vec4 n = vec4(getViewNormal(vUv),1.);//normalize(texture2D(tNormal,vUv));//\n                    float depthMain = texture2D(tDepth,vUv).r;\n                    float depthGround = texture2D(groundDepth,vUv).r;\n\n                    vec2 groundUv;//叠上贴图，需要把地板视图转为uv\n                    if(\n                        // (n.r!=0. ||n.g!=0. ||n.b!=0.) && \n                        depthGround<depthMain){\n                        //先获取片元到视角向量(eyePos)\n                        float viewZ = getViewZ( depthGround );\n                        float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];\n\t\t\t            vec4 viewPosition= getViewPosition( vUv, depthGround, clipW ); //地面视图空间坐标获取到了\n                        \n                        //反射方向\n                        vec3 reflectDir = normalize(reflect(viewPosition.xyz,n.xyz));\n                        //开始前进\n                        color = vec4(1.);//texture2D(tDiffuse,vec2(reflectDir.y,reflectDir.x));\n                        \n\n                        vec4 startView = vec4(viewPosition.xyz + (reflectDir *           0.), 1.);\n                        vec4 endView   = vec4(viewPosition.xyz + (reflectDir * maxDistance), 1.);\n\n                        vec2 texSize  = u_resolution;\n                        vec2 texCoord = gl_FragCoord.xy / texSize;\n\n                        vec4 startFrag = cameraProjectionMatrix * startView;\n                        startFrag.xyz/=startFrag.w;\n                        startFrag.xy  = (startFrag.xy  + 1.)* 0.5;\n                        startFrag.xy  *= texSize;\n\n                        vec4 endFrag = cameraProjectionMatrix * endView;\n                        endFrag.xyz/=endFrag.w;\n                        endFrag.xy  = (endFrag.xy+1.) * 0.5;\n                        endFrag.xy  *= texSize;\n\n                        vec4 positionTo = viewPosition;\n\n                        vec4 uv = vec4(0.0);\n                        vec2 frag = startFrag.xy;\n                        uv.xy = frag / texSize;\n                        float deltaX    = endFrag.x - startFrag.x;\n                        float deltaY    = endFrag.y - startFrag.y;\n                        // 防止屏幕中间出现黑线\n                        if(deltaX==0.){\n                            deltaX=1.;\n                        }\n                        if(deltaY==0.){\n                            deltaY=1.;\n                        }\n                        \n                        float useX      = abs(deltaX) >= abs(deltaY) ? 1. : 0.;\n                        float delta     = mix(abs(deltaY), abs(deltaX), useX) * clamp(resolution, 0., 1.);\n                        vec2  increment = vec2(deltaX, deltaY) / max(delta, 0.001);\n                        \n                        //float curPositionX;\n                        //float curPositionY;\n                        // curPositionX = (startFrag.x)*(1.-search1)+(endFrag.x)*search1;\n                        // curPositionY = (startFrag.y)*(1.-search1)+(endFrag.y)*search1;\n\n\n                        float search0 = 0.;\n                        float search1 = 0.;\n                        \n                        int hit0 = 0;\n                        int hit1 = 0;\n\n                        float viewDistance = startView.z;\n                        float depth        = 0.;\n\n                        float i = 0.;\n                        for(i=0.;i<delta;i+=1.){\n                            frag      += increment;\n                            uv.xy      = frag / texSize;\n                            if(uv.x>1. || uv.y>1. || uv.x<0. || uv.y<0.){\n                                break;\n                            }\n                            \n                            float dd = texture2D(tDepth,uv.xy).r;\n                            float viewZZ = getViewZ( dd );\n                            float clipWW = cameraProjectionMatrix[2][3] * viewZZ+cameraProjectionMatrix[3][3];\n                            positionTo = vec4( getViewPosition( uv.xy, dd, clipWW ).xyz,1.); //地面视图空间坐标获取到了\n                           \n                            \n                            search1 = mix\n                                ( (frag.y - startFrag.y) / deltaY\n                                , (frag.x - startFrag.x) / deltaX\n                                , useX\n                                );\n                            search1 = clamp(search1, 0.0, 1.0);\n                            viewDistance = (startView.z * endView.z) / mix(endView.z, startView.z, search1);\n                            depth        = abs(positionTo.z)-abs(viewDistance);\n                            float wtfD = abs(viewDistance)-abs(positionTo.z);\n                            if (\n                                depth>wtfD &&\n                                depth < thickness \n                                && dd!=1. ) \n                            {\n                                hit0 = 1;\n                                break;\n                            }\n                        }\n\n                        if(hit0>0){\n                            color = texture2D(tDiffuse,uv.xy);//vec4(0.,1.,0.,1.);\n                            color.a = 0.5;\n                            //可以在这里模糊化反射\n                        }\n                        \n                    }\n                    vec4 baseColor = texture2D(groundTexture,vUv);\n                    if(color.r==1. &&color.g==1. &&color.b==1. ){\n                        color = mix(baseColor,color,0.2);\n                    }\n                    gl_FragColor = color;\n\n                }"}),e.addPass(n);var g=new y["m"](16777215,3);g.rotation.x=10,g.rotation.z=10,c.add(g);var h=new y["m"](16777215,1);h.rotation.x=10,h.rotation.z=10,u.add(h);new j["a"](o,w.domElement);i.appendChild(w.domElement);var b="textures/",D=".png",O=[b+"px"+D,b+"nx"+D,b+"py"+D,b+"ny"+D,b+"pz"+D,b+"nz"+D],T=(new y["i"]).load(O);c.background=T;var V=W(),_=Z(),N=U();function S(t){e.renderer.setRenderTarget(V),e.renderer.render(c,o),n.uniforms.tDepth.value=V.depthTexture,e.renderer.setRenderTarget(_),n.uniforms.tNormal.value=_.texture,n.uniforms.groundDepth.value=_.depthTexture,e.renderer.render(l,o),e.renderer.setRenderTarget(N),n.uniforms.groundTexture.value=N.texture,e.renderer.render(u,o),e.renderer.setRenderTarget(null),e.render()}function W(){var e=new y["Db"](window.innerWidth,window.innerHeight);return e.texture.minFilter=y["V"],e.texture.magFilter=y["V"],e.stencilBuffer=y["j"]===y["k"],e.depthTexture=new y["l"],e.depthTexture.format=y["j"],e.depthTexture.type=y["zb"],e}function Z(){var e=new y["Db"](window.innerWidth,window.innerHeight,{minFilter:y["V"],magFilter:y["V"],format:y["jb"],type:y["u"]});return e.stencilBuffer=y["j"]===y["k"],e.depthTexture=new y["l"],e.depthTexture.format=y["j"],e.depthTexture.type=y["zb"],e}function U(){var e=new y["Db"](window.innerWidth,window.innerHeight,{minFilter:y["V"],magFilter:y["V"],format:y["jb"],type:y["u"]});return e}function k(e,n){var t=new y["O"],r=new y["O"];return t.set(e.width/2,0,0,e.x+e.width/2,0,e.height/2,0,e.y+e.height/2,0,0,(n.far-n.near)/2,(n.far+n.near)/2,0,0,0,1),r.getInverse(t,!0),r}(new P["a"]).setPath("car/").load("scene.gltf",(function(e){c.add(e.scene),e.scene.position.y=.55,e.scene.position.z=-2}))}))}});t("ff07");const T=o()(O,[["render",b],["__scopeId","data-v-19c26887"]]);var V=T,_=[{path:"/",name:"Home",component:m},{path:"/water",name:"Water",component:V}],N=Object(v["a"])({history:Object(v["b"])(),routes:_}),S=N;Object(r["b"])(u).use(S).mount("#app")},"57ed":function(e,n,t){"use strict";t("7de0")},"7de0":function(e,n,t){},ff07:function(e,n,t){"use strict";t("10c7")}});
//# sourceMappingURL=app.47110dd0.js.map