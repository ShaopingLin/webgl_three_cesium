(function(e){function n(n){for(var r,o,c=n[0],u=n[1],l=n[2],s=0,v=[];s<c.length;s++)o=c[s],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&v.push(a[o][0]),a[o]=0;for(r in u)Object.prototype.hasOwnProperty.call(u,r)&&(e[r]=u[r]);d&&d(n);while(v.length)v.shift()();return i.push.apply(i,l||[]),t()}function t(){for(var e,n=0;n<i.length;n++){for(var t=i[n],r=!0,c=1;c<t.length;c++){var u=t[c];0!==a[u]&&(r=!1)}r&&(i.splice(n--,1),e=o(o.s=t[0]))}return e}var r={},a={app:0},i=[];function o(n){if(r[n])return r[n].exports;var t=r[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.m=e,o.c=r,o.d=function(e,n,t){o.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,n){if(1&n&&(e=o(e)),8&n)return e;if(4&n&&"object"===typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)o.d(t,r,function(n){return e[n]}.bind(null,r));return t},o.n=function(e){var n=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(n,"a",n),n},o.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},o.p="/webgl_three_cesium/";var c=window["webpackJsonp"]=window["webpackJsonp"]||[],u=c.push.bind(c);c.push=n,c=c.slice();for(var l=0;l<c.length;l++)n(c[l]);var d=u;i.push([0,"chunk-vendors"]),t()})({0:function(e,n,t){e.exports=t("56d7")},"56d7":function(e,n,t){"use strict";t.r(n);t("e260"),t("e6cf"),t("cca6"),t("a79d");var r=t("7a23");function a(e,n){var t=Object(r["t"])("router-view");return Object(r["n"])(),Object(r["c"])(t)}t("57ed");var i=t("6b0d"),o=t.n(i);const c={},u=o()(c,[["render",a]]);var l=u,d=t("6c02"),s={class:"home"};function v(e,n,t,a,i,o){return Object(r["n"])(),Object(r["d"])("div",s,[Object(r["e"])("div",{onClick:n[0]||(n[0]=function(){return a.water&&a.water.apply(a,arguments)})},"去水")])}var f={name:"Home",components:{},setup:function(){Object(d["c"])();var e=Object(d["d"])();function n(){e.push("/water")}return{water:n}}};const p=o()(f,[["render",v]]);var w=p,h=function(e){return Object(r["q"])("data-v-e428e6c2"),e=e(),Object(r["o"])(),e},m={class:"waterRoot"},x=h((function(){return Object(r["e"])("div",{id:"threeContainer"},null,-1)})),g=[x];function b(e,n,t,a,i,o){return Object(r["n"])(),Object(r["d"])("div",m,g)}var y=t("5a89"),D=t("5c40"),j=t("4721"),P=t("34ad"),F=t("32d9"),O=t("360d"),z=t("93e9"),V=(t("31f6"),{name:"Water",setup:function(e,n){Object(D["v"])((function(){var e,n,t,r=document.getElementById("threeContainer"),a=new y["bb"](70,window.innerWidth/window.innerHeight,.01,1e3);a.position.z=10.2,a.position.y=.5;var i=new y["lb"],o=new y["lb"],c=new y["cb"](50,50,1,1),u=new y["R"],l=new y["P"](c,u);l.rotation.x=-Math.PI/2,o.add(l);var d=new y["Eb"]({antialias:!0});d.setSize(window.innerWidth,window.innerHeight),d.setAnimationLoop(g),t=new z["a"](i,a),e=new F["a"](d),e.addPass(t);var s=V({x:0,y:0,width:window.innerWidth,height:window.innerHeight},{near:0,far:1});n=new O["a"]({glslVersion:y["s"],uniforms:{tDiffuse:{value:null},tDepth:{value:null},cameraNear:{value:a.near},cameraFar:{value:a.far},tNormal:{value:null},groundDepth:{value:null},viewPortMatrixInverse:{value:s},projectionMatrixInverse:{value:a.projectionMatrixInverse},cameraProjectionMatrix:{value:a.projectionMatrix},u_resolution:{value:new y["Ab"](window.innerWidth,window.innerHeight)}},vertexShader:"\n                varying vec2 vUv;\n                varying vec3 v_position;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n                }",fragmentShader:"\n                #include <packing>\n                varying vec2 vUv;\n                uniform float cameraNear;\n                uniform float cameraFar;\n                uniform sampler2D tDiffuse;\n                uniform sampler2D tDepth;\n                uniform sampler2D tNormal;\n                uniform sampler2D groundDepth;\n                uniform mat4 viewPortMatrixInverse;\n                uniform mat4 projectionMatrixInverse;\n                uniform mat4 cameraProjectionMatrix;\n                uniform vec2 u_resolution;\n               \n                float readDepth( sampler2D depthSampler, vec2 coord ) {\n                    float fragCoordZ = texture2D( depthSampler, coord ).x;\n                    float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n                    return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n                }\n                vec3 getViewNormal( const in vec2 uv ) {\n                    return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );\n                }\n                float getViewZ( const in float depth ) {\n                    return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n                }\n                vec4 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n                    vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n                    clipPosition *= clipW; //clip\n                    return ( projectionMatrixInverse * clipPosition );//view\n                }\n                void main() {\n                    float maxDistance = 15.;\n                    float resolution  = 1.0;\n                    // float   steps       = 5.;\n                    float thickness   = .1;\n                    \n\n                    vec4 color = texture2D(tDiffuse,vUv);\n                    vec4 n = vec4(getViewNormal(vUv),1.);//texture2D(tNormal,vUv);\n                    float depthMain = texture2D(tDepth,vUv).r;\n                    float depthGround = texture2D(groundDepth,vUv).r;\n                    if(\n                        // (n.r!=0. ||n.g!=0. ||n.b!=0.) && \n                        depthGround<depthMain){\n                        //先获取片元到视角向量(eyePos)\n                        float viewZ = getViewZ( depthGround );\n                        float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];\n\t\t\t            vec4 viewPosition= getViewPosition( vUv, depthGround, clipW ); //地面视图空间坐标获取到了\n                        \n                        //反射方向\n                        vec3 reflectDir = normalize(reflect(viewPosition.xyz,n.xyz));\n                        //开始前进\n                        color = vec4(1.);//texture2D(tDiffuse,vec2(reflectDir.y,reflectDir.x));\n                        \n\n                        vec4 startView = vec4(viewPosition.xyz + (reflectDir *           0.), 1.);\n                        vec4 endView   = vec4(viewPosition.xyz + (reflectDir * maxDistance), 1.);\n\n                        vec2 texSize  = u_resolution;\n                        vec2 texCoord = gl_FragCoord.xy / texSize;\n\n                        vec4 startFrag = cameraProjectionMatrix * startView;\n                        startFrag.xyz/=startFrag.w;\n                        startFrag.xy  = (startFrag.xy  + 1.)* 0.5;\n                        startFrag.xy  *= texSize;\n\n                        vec4 endFrag = cameraProjectionMatrix * endView;\n                        endFrag.xyz/=endFrag.w;\n                        endFrag.xy  = (endFrag.xy+1.) * 0.5;\n                        endFrag.xy  *= texSize;\n\n                        vec4 positionTo = viewPosition;\n\n                        vec4 uv = vec4(0.0);\n                        vec2 frag = startFrag.xy;\n                        uv.xy = frag / texSize;\n                        float deltaX    = endFrag.x - startFrag.x;\n                        float deltaY    = endFrag.y - startFrag.y;\n                        \n                        float useX      = abs(deltaX) >= abs(deltaY) ? 1. : 0.;\n                        float delta     = mix(abs(deltaY), abs(deltaX), useX) * clamp(resolution, 0., 1.);\n                        vec2  increment = vec2(deltaX, deltaY) / max(delta, 0.001);\n                        \n                        //float curPositionX;\n                        //float curPositionY;\n                        // curPositionX = (startFrag.x)*(1.-search1)+(endFrag.x)*search1;\n                        // curPositionY = (startFrag.y)*(1.-search1)+(endFrag.y)*search1;\n\n\n                        float search0 = 0.;\n                        float search1 = 0.;\n                        \n                        int hit0 = 0;\n                        int hit1 = 0;\n\n                        float viewDistance = startView.z;\n                        float depth        = 0.;\n\n                        float i = 0.;\n                        for(i=0.;i<delta;i+=1.){\n                            frag      += increment;\n                            uv.xy      = frag / texSize;\n                            if(uv.x>1. || uv.y>1. || uv.x<0. || uv.y<0.){\n                                break;\n                            }\n                            \n                            float dd = texture2D(tDepth,uv.xy).r;\n                            float viewZZ = getViewZ( dd );\n                            float clipWW = cameraProjectionMatrix[2][3] * viewZZ+cameraProjectionMatrix[3][3];\n                            positionTo = vec4( getViewPosition( uv.xy, dd, clipWW ).xyz,1.); //地面视图空间坐标获取到了\n                           \n                            \n                            search1 = mix\n                                ( (frag.y - startFrag.y) / deltaY\n                                , (frag.x - startFrag.x) / deltaX\n                                , useX\n                                );\n                            search1 = clamp(search1, 0.0, 1.0);\n                            viewDistance = (startView.z * endView.z) / mix(endView.z, startView.z, search1);\n                            depth        = abs(positionTo.z)-abs(viewDistance);\n                            float wtfD = abs(viewDistance)-abs(positionTo.z);\n                            if (\n                                depth>wtfD &&\n                                depth < thickness \n                                && dd!=1. ) \n                            {\n                                hit0 = 1;\n                                break;\n                            }\n                        }\n\n                        if(hit0>0){\n                            color = texture2D(tDiffuse,uv.xy);//vec4(0.,1.,0.,1.);\n                        }\n                        \n                    }\n                    gl_FragColor = color;\n\n                }"}),e.addPass(n);var v=new y["m"](16777215,2.5);v.rotation.x=10,v.rotation.z=10,i.add(v);new j["a"](a,d.domElement);r.appendChild(d.domElement);var f="textures/",p=".png",w=[f+"px"+p,f+"nx"+p,f+"py"+p,f+"ny"+p,f+"pz"+p,f+"nz"+p],h=(new y["i"]).load(w);i.background=h;var m=b(),x=D();function g(t){e.renderer.setRenderTarget(m),e.renderer.render(i,a),n.uniforms.tDepth.value=m.depthTexture,e.renderer.setRenderTarget(x),e.renderer.render(o,a),n.uniforms.tNormal.value=x.texture,n.uniforms.groundDepth.value=x.depthTexture,e.renderer.setRenderTarget(null),e.render()}function b(){var e=new y["Db"](window.innerWidth,window.innerHeight);return e.texture.minFilter=y["V"],e.texture.magFilter=y["V"],e.stencilBuffer=y["j"]===y["k"],e.depthTexture=new y["l"],e.depthTexture.format=y["j"],e.depthTexture.type=y["zb"],e}function D(){var e=new y["Db"](window.innerWidth,window.innerHeight,{minFilter:y["V"],magFilter:y["V"],format:y["jb"],type:y["u"]});return e.stencilBuffer=y["j"]===y["k"],e.depthTexture=new y["l"],e.depthTexture.format=y["j"],e.depthTexture.type=y["zb"],e}function V(e,n){var t=new y["O"],r=new y["O"];return t.set(e.width/2,0,0,e.x+e.width/2,0,e.height/2,0,e.y+e.height/2,0,0,(n.far-n.near)/2,(n.far+n.near)/2,0,0,0,1),r.getInverse(t,!0),r}(new P["a"]).setPath("car/").load("scene.gltf",(function(e){i.add(e.scene),e.scene.position.y=.5,e.scene.position.z=-2}))}))}});t("d2f9");const M=o()(V,[["render",b],["__scopeId","data-v-e428e6c2"]]);var T=M,_=[{path:"/",name:"Home",component:w},{path:"/water",name:"Water",component:T}],S=Object(d["a"])({history:Object(d["b"])(),routes:_}),W=S;Object(r["b"])(l).use(W).mount("#app")},"57ed":function(e,n,t){"use strict";t("7de0")},"5d29":function(e,n,t){},"7de0":function(e,n,t){},d2f9:function(e,n,t){"use strict";t("5d29")}});
//# sourceMappingURL=app.c0befa33.js.map